<!DOCTYPE html>
<html>

  <head>
    <title>HotQR scanner</title>
    <link rel="shortcut icon" href="#" />
    <script src="zxing_reader.js"></script>
    <script src="lzma_worker-min.js"></script>
    <script src="hotqr_reader.js"></script>
    <!--<script src="zxing_reader.unmin.js"></script>-->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="HotQR Scanner">
    <link rel="apple-touch-icon" sizes="144x144" href="htqr_read.png">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
<style>
html, body{ margin:0;padding:0}
#canvas {
  width: 98vw; /* 100% of the viewport width */
  padding:0;
  margin:0;
  max-width: 800px;
  height: auto; /* maintain aspect ratio */
  display: block;
  border: 2px solid red;
}
</style>
  </head>

  <body style="text-align: center">
    <table><tr>
        <td>
          Camera:<br/>
          <select id="cameraSelector">
            <option value="user">Front Camera</option>
            <option value="environment">Back Camera</option>
          </select>
        </td>
        <td>
          Format:<br/>
          <select id="format">
            <option value="">Any</option>
            <option value="Aztec">Aztec</option>
            <option value="Code39">Codabar</option>
            <option value="CODE_39">Code39</option>
            <option value="Code93">Code93</option>
            <option value="Code128">Code128</option>
            <option value="DataMatrix">DataMatrix</option>
            <option value="DataBar">DataBar</option>
            <option value="DataBarExpanded">DataBarExpanded</option>
            <option value="DataBarLimited">DataBarLimited</option>
            <option value="DXFilmEdge">DXFilmEdge</option>
            <option value="EAN8">EAN-8</option>
            <option value="EAN13">EAN-13</option>
            <option value="ITF">ITF</option>
            <option value="PDF417">PDF417</option>
            <option value="QRCode" selected>QRCode</option>
            <option value="MicroQRCode">Micro QRCode</option>
            <option value="RMQRCode">rMQR Code</option>
            <option value="UPCA">UPC-A</option>
            <option value="UPCE">UPC-E</option>
            <option value="LinearCodes">Linear Codes</option>
            <option value="MatrixCodes">Matrix Codes</option>
          </select>
        </td>
        <td>
          <label><input id="colorSweep" type="checkbox" checked>R→G→B→Gray</label>
        </td>
        <td>
          Mode:<br/>
          <select id="mode">
            <option value="true" selected="">Normal</option>
            <option value="false">Fast</option>
          </select>
        </td>
        <td>
          Focus:<br />
          <input id="focusControl" type="range" min="0" max="100" value="50" />
        </td>
        <td>
          Info:<br/>
          <input id="inputTextOut" />
        </td>
      </tr>
    </table>
    <br /><br />

    <canvas id="canvas" width="640" height="480"></canvas>

    <!-- RGB channel previews -->
    <div id="rgb-previews" style="display:none; margin:8px auto; max-width:800px;">
      <canvas id="prev-red"   width="160" height="120" style="margin:0 4px; border:1px solid #aaa;"></canvas>
      <canvas id="prev-green" width="160" height="120" style="margin:0 4px; border:1px solid #aaa;"></canvas>
      <canvas id="prev-blue"  width="160" height="120" style="margin:0 4px; border:1px solid #aaa;"></canvas>
    </div>
    
    <br /><br />
    <div id="scanview" style="width:420px"></div>

    <div id="result"></div>

    <div id="file-links"></div>
    <div id="qr-reader-results"></div>

    <script>
      function isPhone() {
        return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      //if iPhone:
      if (isPhone())
      {
        document.getElementById('cameraSelector').value = "environment";
      }
      else
      {
        document.getElementById('cameraSelector').value = "user"; // front camera
      }
    </script>

    <!-- Main logic -->
    <script>
      // Initialize ZXing
      var zxing = ZXing().then(function (instance) {
        zxing = instance; // required with current emsdk
      });
      
      // DOM refs
      const cameraSelector = document.getElementById("cameraSelector");
      const focusControl = document.getElementById("focusControl");      
      const format = document.getElementById("format");
      const mode = document.getElementById("mode");
      const canvas = document.getElementById("canvas");
      const resultElement = document.getElementById("result");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const video = document.createElement("video");

      video.setAttribute("id", "video");
      video.setAttribute("width", canvas.width);
      video.setAttribute("height", canvas.height);
      video.setAttribute("autoplay", "");
      video.setAttribute("playsinline", ""); // avoid iOS fullscreen

      let stream;

      // ---------- WASM heap reuse for speed ----------
      const wasmHeapCache = { ptr: 0, bytes: 0 };
      function readBarcodeFromCanvasInternal(rgbaBuffer, imgWidth, imgHeight, formatName, tryHarder) {
        if (!zxing || !zxing.readBarcodeFromPixmap) return null;

        const needBytes = rgbaBuffer.byteLength;
        if (wasmHeapCache.bytes !== needBytes) {
          if (wasmHeapCache.ptr) {
            try { zxing._free(wasmHeapCache.ptr); } catch (e) {}
          }
          wasmHeapCache.ptr = zxing._malloc(needBytes);
          wasmHeapCache.bytes = needBytes;
        }

        zxing.HEAPU8.set(rgbaBuffer, wasmHeapCache.ptr);
        // readBarcodeFromPixmap(ptr, width, height, tryHarder, format);
        return zxing.readBarcodeFromPixmap(wasmHeapCache.ptr, imgWidth, imgHeight, tryHarder, formatName);
      }

      // ---------- Filtering helpers ----------
      function makeFilteredBuffer(src, pass) {
        const out = new Uint8ClampedArray(src.length);
        for (let i = 0; i < src.length; i += 4) {
          const r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];
          let R=r, G=g, B=b;
          if (pass === 'red')       { G = 0; B = 0; }
          else if (pass === 'green'){ R = 0; B = 0; }
          else if (pass === 'blue') { R = 0; G = 0; }
          else if (pass === 'gray') {
            const y = (0.2126*r + 0.7152*g + 0.0722*b) | 0;
            R = G = B = y;
          }
          out[i]=R; out[i+1]=G; out[i+2]=B; out[i+3]=a;
        }
        return out;
      }

      function tryDecodeWithFiltersAll(imageData, formatName, tryHarder, sweepEnabled) {
        const results = [];
        const seen = new Set();
        const pushIfNew = (res) => {
          if (res && res.format && !res.error && res.text && !seen.has(res.text)) {
            seen.add(res.text);
            results.push(res);
          }
        };

        if (!sweepEnabled) {
          pushIfNew(readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, formatName, tryHarder));
          return results;
        }

        const order = ['red','green','blue','gray'];
        for (const pass of order) {
          const buf = makeFilteredBuffer(imageData.data, pass);
          pushIfNew(readBarcodeFromCanvasInternal(buf, imageData.width, imageData.height, formatName, tryHarder));
        }

        // Also try original pixels
        pushIfNew(readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, formatName, tryHarder));
        return results;
      }

      // ---------- RGB previews ----------
      function updateRgbPreviews(imageData) {
        const box = document.getElementById('rgb-previews');
        const enabled = document.getElementById('colorSweep')?.checked;
        box.style.display = enabled ? 'block' : 'none';
        if (!enabled) return;

        const passes = [
          { id: 'prev-red',   mode: 'red' },
          { id: 'prev-green', mode: 'green' },
          { id: 'prev-blue',  mode: 'blue' },
        ];

        for (const p of passes) {
          const buf = makeFilteredBuffer(imageData.data, p.mode);
          const id = new ImageData(new Uint8ClampedArray(buf), imageData.width, imageData.height);
          const cvs = document.getElementById(p.id);
          const cctx = cvs.getContext('2d', { willReadFrequently: true });

          // Draw with scaling; OffscreenCanvas if available, otherwise a temp canvas
          let tmp;
          if (typeof OffscreenCanvas !== 'undefined') {
            tmp = new OffscreenCanvas(imageData.width, imageData.height);
          } else {
            tmp = document.createElement('canvas');
            tmp.width = imageData.width; tmp.height = imageData.height;
          }
          const tctx = tmp.getContext('2d');
          tctx.putImageData(id, 0, 0);
          cctx.clearRect(0, 0, cvs.width, cvs.height);
          cctx.drawImage(tmp, 0, 0, cvs.width, cvs.height);
        }
      }

      // ---------- Frame loop ----------
      const processFrame = function () {
        if (!video.videoWidth) { requestAnimationFrame(processFrame); return; }

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        updateRgbPreviews(imageData);

        const sweep = document.getElementById('colorSweep')?.checked;
        const tryHarder = (mode.value === 'true');
        const codes = tryDecodeWithFiltersAll(imageData, format.value, tryHarder, sweep);

        if (codes.length) {
          // Show all found texts
          resultElement.innerText = codes.map(c => c.text).join('\n');
          for (const code of codes) {
            // HotQR bookkeeping
            try {
              dScans[code.text] = '1';
              szCachedLastScan = code.text;
              processScanData();
            } catch (e) {
              // If hotqr_reader.js not ready, ignore
            }
            // Outline each detection
            if (code.position) {
              ctx.beginPath();
              ctx.lineWidth = 4;
              ctx.strokeStyle = "red";
              const p = code.position;
              ctx.moveTo(p.topLeft.x, p.topLeft.y);
              ctx.lineTo(p.topRight.x, p.topRight.y);
              ctx.lineTo(p.bottomRight.x, p.bottomRight.y);
              ctx.lineTo(p.bottomLeft.x, p.bottomLeft.y);
              ctx.closePath();
              ctx.stroke();
            }
          }
        } else {
          resultElement.innerText = "No barcode found";
        }
        requestAnimationFrame(processFrame);
      };

      // ---------- Camera setup ----------
      const updateVideoStream = async function () {
        // Stop previous
        if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

        const constraints = {
          audio: false,
          video: {
            facingMode: cameraSelector.value,
            width: { ideal: 1280 }, height: { ideal: 720 },
            advanced: [{ focusMode: 'continuous' }]
          }
        };

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e) {
          console.error('getUserMedia failed, retrying with default constraints', e);
          stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        }

        video.srcObject = stream;
        video.play();

        const track = stream.getVideoTracks()[0];

        // Focus slider wiring (best-effort)
        focusControl.oninput = async () => {
          try {
            const v = Number(focusControl.value)/100;
            await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: v }] });
          } catch { /* ignore if unsupported */ }
        };

        const capabilities = (track.getCapabilities && track.getCapabilities()) || {};
        if (capabilities.focusDistance) {
          focusControl.disabled = false;
          focusControl.min = capabilities.focusDistance.min;
          focusControl.max = capabilities.focusDistance.max;
          focusControl.step = capabilities.focusDistance.step || 1;
        } else {
          focusControl.disabled = true;
        }

        requestAnimationFrame(processFrame);
      };

      cameraSelector.addEventListener("change", function () {
        updateVideoStream();
      });

      // kick things off
      updateVideoStream();

      // Optional PWA
      if ('serviceWorker' in navigator) {
        // navigator.serviceWorker.register('./sw.js').catch(console.error);
      }
    </script>
  </body>
</html>
