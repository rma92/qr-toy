<!DOCTYPE html>
<html>
<head>
  <title>Camera Focus Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
  <style>
    #container {
      height: 480px;
      width: 100%;
      background: lightgray;
      position: relative;
    }

    video {
      position: absolute;
      height: 100%;
      width: 100%;
      left:0;
      top:0;
      object-fit: contain;
    }

    button {
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h2>Camera Focus Demo</h2>
  <label>
    Camera:
    <select id="select-camera"></select>
  </label>
  <label>
    Resolution:
    <select id="select-resolution">
      <option value="320x240">160x120</option>
      <option value="320x240">320x240</option>
      <option value="640x480">640x480</option>
      <option value="1280x720">1280x720</option>
      <option value="1920x1080" selected>1920x1080</option>
      <option value="3840x2160">3840x2160</option>
    </select>
  </label>
  <br/>
  <label>
    Mode:
    <select id="select-mode">
      <option value="manual" selected>manual</option>
      <option value="continuous">continuous</option>
    </select>
  </label>
  <br/>
  <label>
    Focus distance:
    <input type="range" id="distance" min="0" max="3" value="0" step="0" onchange="changeDistance()"/>
  </label>
  <br/>
  <button onclick="startCamera();">Start Camera</button>
  <br/>

      <table><tr>
        <td>
          Camera:<br/>
          <select id="cameraSelector">
            <option value="user">Front Camera</option>
            <option value="environment">Back Camera</option>
          </select>
        </td>
        <td>
          Format:<br/>
          <select id="format">
            <option value="" selected="">Any</option>
            <option value="Aztec">Aztec</option>
            <option value="Code39">Codabar</option>
            <option value="CODE_39">Code39</option>
            <option value="Code93">Code93</option>
            <option value="Code128">Code128</option>
            <option value="DataMatrix">DataMatrix</option>
            <option value="DataBar">DataBar</option>
            <option value="DataBarExpanded">DataBarExpanded</option>
            <option value="DataBarLimited">DataBarLimited</option>
            <option value="DXFilmEdge">DXFilmEdge</option>
            <option value="EAN8">EAN-8</option>
            <option value="EAN13">EAN-13</option>
            <option value="ITF">ITF</option>
            <option value="PDF417">PDF417</option>
            <option value="QRCode">QRCode</option>
            <option value="MicroQRCode">Micro QRCode</option>
            <option value="RMQRCode">rMQR Code</option>
            <option value="UPCA">UPC-A</option>
            <option value="UPCE">UPC-E</option>
            <option value="LinearCodes">Linear Codes</option>
            <option value="MatrixCodes">Matrix Codes</option>
          </select>
        </td>
        <td>
          Mode:<br/>
          <select id="mode">
            <option value="true" selected="">Normal</option>
            <option value="false">Fast</option>
          </select>
        </td>
        <td>
          Focus:<br />
          <input id="focusControl" type="range" min="0" max="100" value="50" />
        </td>
        <td>
          Info:<br/>
          <input id="inputTextOut" />
        </td>
      </tr>
    </table>
    <br /><br />


  <div id="container">
    <video id="video" muted autoplay="autoplay" playsinline="playsinline" webkit-playsinline></video>
    <canvas id="canvas"></canvas>
  </div>
    <br /><br />
    <div id="scanview" style="width:420px"></div>

    <div id="result"></div>

    <div id="file-links"></div>
    <div id="qr-reader-results"></div>

        <script src="lzma_worker-min.js"></script>
    <script src="hotqr_reader.js"></script>
    <script src="zxing_reader.unmin.js"></script>
  <script type="text/javascript">
    let cameras = [];
    let track;
    let step = 0.5;
    window.onload = async function(){
      checkBrowserCapabilities();
      await requestCameraPermission();
      await listCameras();
      registerEvents();
    }

    async function requestCameraPermission() {
      try {
        const constraints = {video: true, audio: false};
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        closeStream(stream);
      } catch (error) {
        console.log(error);
        throw error;
      }
    }

    function closeStream(stream){
      if (stream) {
        const tracks = stream.getTracks();
        for (let i=0;i<tracks.length;i++) {
          const track = tracks[i];
          track.stop();  // stop the opened tracks
        }
      }
    }

    async function startCamera(){
      let selectedCamera = cameras[document.getElementById("select-camera").selectedIndex];
      closeStream(document.getElementById("video").srcObject);
      let selectedResolution = document.getElementById("select-resolution").selectedOptions[0].value;
      let width = parseInt(selectedResolution.split("x")[0]);
      let height = parseInt(selectedResolution.split("x")[1]);
      
      const videoConstraints = {
        video: {width:width, height:height, deviceId: selectedCamera.deviceId}, 
        audio: false
      };
      try {
        const cameraStream = await navigator.mediaDevices.getUserMedia(videoConstraints);
        document.getElementById("video").srcObject = cameraStream;
        checkCameraCapabilities();
      } catch (error) {
        alert(error);
      }
    }

    async function listCameras(){
      let cameraSelect = document.getElementById("select-camera");
      let allDevices = await navigator.mediaDevices.enumerateDevices();
      for (let i = 0; i < allDevices.length; i++){
        let device = allDevices[i];
        if (device.kind == 'videoinput'){
          cameras.push(device);
          cameraSelect.appendChild(new Option(device.label,device.deviceId));
        }
      }
    }

    function registerEvents(){
      console.log("registerEvents");
      const container = document.getElementById("container");
    }

    async function focus(x,y){
      const video = document.querySelector('video');
      x = video.videoWidth * x;
      y = video.videoHeight * y;

      let mode = document.getElementById("select-mode").selectedOptions[0].value;
      //https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints
      const constraints = {advanced: [{
        focusMode: mode
      }]};
      console.log(constraints);
      await track.applyConstraints(constraints);
    }

    function checkBrowserCapabilities(){
      if (navigator.mediaDevices.getSupportedConstraints().focusMode) {
        console.log("The browser supports focus");
      }else{
        //alert("The browser does not support focus.");
      }
    }

    function checkCameraCapabilities(){
      const video = document.querySelector("video");
      const videoTracks = video.srcObject.getVideoTracks();
      track = videoTracks[0];
      let capabilities = track.getCapabilities();
      console.log(capabilities);
      if (!('focusMode' in capabilities)) {
        alert("This camera does not support focus");
      }else{
        if (!('focusDistance' in capabilities)) {
          alert("This camera does not control focus distance");
        }else{
          loadFocusDistanceRange(capabilities);
        }
      }
    }

    function loadFocusDistanceRange(cap){
      step = cap.focusDistance.step;
      min = cap.focusDistance.min;
      max = cap.focusDistance.max;
      currentDistance = track.getSettings().focusDistance;
      let range = document.getElementById("distance");
      range.value = currentDistance;
      range.min = min;
      range.max = max;
      range.step = step;
    }

    async function changeDistance(){
      let mode = document.getElementById("select-mode").selectedOptions[0].value;
      //https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints
      currentDistance = document.getElementById("distance").value;
      const constraints = {advanced: [{
        focusMode: mode,
        focusDistance: currentDistance,
      }]};
      console.log(constraints);
      await track.applyConstraints(constraints);
    }

    //Reader
    var zxing = ZXing().then(function (instance) {
      zxing = instance; // this line is supposedly not required but with current emsdk it is :-/
    });

                const format = document.getElementById("format");
      const mode = document.getElementById("mode");
      const canvas = document.getElementById("canvas");
      const resultElement = document.getElementById("result");

      const ctx = canvas.getContext("2d", { willReadFrequently: true });

                function readBarcodeFromCanvas(canvas, format, mode) {
        var imgWidth = canvas.width;
        var imgHeight = canvas.height;
        var imageData = canvas.getContext('2d').getImageData(0, 0, imgWidth, imgHeight);
        var sourceBuffer = imageData.data;

        if (zxing != null) {
          var buffer = zxing._malloc(sourceBuffer.byteLength);
          zxing.HEAPU8.set(sourceBuffer, buffer);
          var result = zxing.readBarcodeFromPixmap(buffer, imgWidth, imgHeight, mode, format);
          zxing._free(buffer);
          return result;
        } else {
          return { error: "ZXing not yet initialized" };
        }
      }

      function drawResult(code) {
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "red";
        // ctx.textAlign = "center";
        // ctx.fillStyle = "#green"
        // ctx.font = "25px Arial";
        // ctx.fontWeight = "bold";
        with (code.position) {
          ctx.moveTo(topLeft.x, topLeft.y);
          ctx.lineTo(topRight.x, topRight.y);
          ctx.lineTo(bottomRight.x, bottomRight.y);
          ctx.lineTo(bottomLeft.x, bottomLeft.y);
          ctx.lineTo(topLeft.x, topLeft.y);
          ctx.stroke();
          // ctx.fillText(code.text, (topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);
        }
      }

      function escapeTags(htmlStr) {
        return htmlStr.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }

      const processFrame = function () {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const code = readBarcodeFromCanvas(canvas, format.value, mode.value === 'true');
        if (code.format) {
          //resultElement.innerText = code.format + ": " + escapeTags(code.text);
          resultElement.innerText = code.text;

          //HotQr    
          //add the scan.
          dScans[ code.text ] = '1';
          szCachedLastScan = code.text;
          processScanData();
          //End HotQR.
          drawResult(code)
        } else {
          resultElement.innerText = "No barcode found";
        }
        requestAnimationFrame(processFrame);
      };

  </script>
</body>
</html>
