<!DOCTYPE html>
<html>

  <head>
    <title>HotQR scanner</title>
    <link rel="shortcut icon" href="#" />
    <script src="zxing_reader.js"></script>
    <script src="lzma_worker-min.js"></script>
    <script src="hotqr_reader.js"></script>
    <!--<script src="zxing_reader.unmin.js"></script>-->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="HotQR Scanner">
    <link rel="apple-touch-icon" sizes="144x144" href="htqr_read.png">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
<style>
html, body{ margin:0;padding:0}
#canvas {
  width: 98vw; /* 100% of the viewport width */
  padding:0;
  margin:0;
  max-width: 800px;
  height: auto; /* maintain aspect ratio */
  display: block;
  border: 2px solid red;
}

</style>
  </head>

  <body style="text-align: center">
    <table><tr>
        <td>
          Camera:<br/>
          <select id="cameraSelector">
            <option value="user">Front Camera</option>
            <option value="environment">Back Camera</option>
          </select>
        </td>
        <td>
          Format:<br/>
          <select id="format">
            <option value="">Any</option>
            <option value="Aztec">Aztec</option>
            <option value="Code39">Codabar</option>
            <option value="CODE_39">Code39</option>
            <option value="Code93">Code93</option>
            <option value="Code128">Code128</option>
            <option value="DataMatrix">DataMatrix</option>
            <option value="DataBar">DataBar</option>
            <option value="DataBarExpanded">DataBarExpanded</option>
            <option value="DataBarLimited">DataBarLimited</option>
            <option value="DXFilmEdge">DXFilmEdge</option>
            <option value="EAN8">EAN-8</option>
            <option value="EAN13">EAN-13</option>
            <option value="ITF">ITF</option>
            <option value="PDF417">PDF417</option>
            <option value="QRCode" selected>QRCode</option>
            <option value="MicroQRCode">Micro QRCode</option>
            <option value="RMQRCode">rMQR Code</option>
            <option value="UPCA">UPC-A</option>
            <option value="UPCE">UPC-E</option>
            <option value="LinearCodes">Linear Codes</option>
            <option value="MatrixCodes">Matrix Codes</option>
          </select>
        </td>
        <td>
          <label><input id="colorSweep" type="checkbox" checked>R→G→B→Gray</label>
        </td>
        <td>
          Mode:<br/>
          <select id="mode">
            <option value="true" selected="">Normal</option>
            <option value="false">Fast</option>
          </select>
        </td>
        <td>
          Focus:<br />
          <input id="focusControl" type="range" min="0" max="100" value="50" />
        </td>
        <td>
          Info:<br/>
          <input id="inputTextOut" />
        </td>
      </tr>
    </table>
    <br /><br />

      <div style="margin: 8px 0; display:flex; gap:8px; align-items:center;">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
        <span id="cameraStatus" style="font-size:0.9em;opacity:0.75;"></span>
      </div>

    <canvas id="canvas" width="640" height="480"></canvas>
    <br /><br />
    <div id="scanview" style="width:420px"></div>

    <div id="result"></div>

    <div id="file-links"></div>
    <div id="qr-reader-results"></div>
    <script>
      function isPhone() {
        return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      //if iPhone:
      if (isPhone())
      {
        document.getElementById('cameraSelector').value = "environment";
      }
      else
      {
        document.getElementById('cameraSelector').value = "user"; // front camera
      }

    </script>
    <script>
      var zxing = ZXing().then(function (instance) {
        zxing = instance; // this line is supposedly not required but with current emsdk it is :-/
      });
      
      const cameraSelector = document.getElementById("cameraSelector");
      const focusControl = document.getElementById("focusControl");      
      const format = document.getElementById("format");
      const mode = document.getElementById("mode");
      const canvas = document.getElementById("canvas");
      const resultElement = document.getElementById("result");

      // --- Performance: preallocate luminance buffer and a reusable WASM heap pointer ---
      let luminanceBuffer = null; // Uint8Array(width*height)
      let wasmLumPtr = 0;         // pointer in ZXing HEAPU8, sized to luminanceBuffer length
      function ensureLumBuffers(w, h) {
        const size = w * h;
        if (!luminanceBuffer || luminanceBuffer.length !== size) {
          luminanceBuffer = new Uint8Array(size);
          if (zxing && wasmLumPtr) { zxing._free(wasmLumPtr); wasmLumPtr = 0; }
          if (zxing) { wasmLumPtr = zxing._malloc(size); }
        }
      }
const ctx = canvas.getContext("2d", { willReadFrequently: true });
      // --- Debounced processScanData (HotQR UI/table update) ---
      let _psdTimer = 0;
      function scheduleProcessScanData() {
        if (typeof processScanData !== 'function') return;
        if (_psdTimer) cancelAnimationFrame(_psdTimer);
        _psdTimer = requestAnimationFrame(() => {
          try { processScanData(); } catch (e) { console.warn('processScanData failed:', e); }
        });
      }

      // --- Scanner control state ---
      let scanning = false;
      const startBtn = document.getElementById('startBtn');
      const stopBtn  = document.getElementById('stopBtn');
      const cameraStatus = document.getElementById('cameraStatus');

      function setStatus(msg) { if (cameraStatus) cameraStatus.textContent = msg || ''; }

      async function startCamera(manual = false) {
        // Ensure attributes that help autoplay on mobile/HTTPS
        try {
          video.setAttribute('playsinline','');
          video.setAttribute('autoplay','');
          video.setAttribute('muted','');
          video.playsInline = true;
          video.autoplay = true;
          video.muted = true; // required for some mobile autoplay policies
        } catch {}

        if (scanning) return;
        try {
          // use current cameraSelector choice; fall back to default if none
          const constraints = {
            video: { facingMode: cameraSelector.value || 'environment' }
          };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;

          // Try to play; if blocked, set up a one-time gesture resume
          let played = false;
          try { await video.play(); played = true; } 
          catch (e) {
            console.warn('video.play() blocked; scheduling gesture-resume', e);
            if (!manual) setStatus('Tap anywhere or press "Start Camera" to begin');
          }
          // If play() was blocked (mobile/Edge), arm a one-time user-gesture to resume playback
          if (!played) {
            const resumeOnGesture = async () => {
              document.removeEventListener('touchstart', resumeOnGesture, {capture:true});
              document.removeEventListener('click', resumeOnGesture, {capture:true});
              try { await video.play(); } catch {}
              // if scanning already true we'll just continue; else set and kick loop
              if (!scanning) {
                scanning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                setStatus('Camera running');
                processFrame();
              }
            };
            document.addEventListener('touchstart', resumeOnGesture, {capture:true, once:true});
            document.addEventListener('click', resumeOnGesture, {capture:true, once:true});
          }

          scanning = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          setStatus('Camera running');
          processFrame(); // kick loop
        } catch (err) {
          console.error('Camera start failed:', err);
          setStatus('Camera error: ' + (err && err.name ? err.name : err));
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      }

      function stopCamera() {
        if (!scanning) return;
        scanning = false;
        if (stream) {
          try { stream.getTracks().forEach(t => t.stop()); } catch {}
          stream = null;
        }
        video.srcObject = null;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('Camera stopped');
        // cleanup any pending gesture-resume listeners
        try {
          document.removeEventListener('touchstart', resumeOnGesture, {capture:true});
          document.removeEventListener('click', resumeOnGesture, {capture:true});
        } catch {}

      }

      startBtn.addEventListener('click', () => startCamera(true));
      stopBtn.addEventListener('click', stopCamera);

      const video = document.createElement("video");
      //var track;

      video.setAttribute("id", "video");
      video.setAttribute("width", canvas.width);
      video.setAttribute("height", canvas.height);
      video.setAttribute("autoplay", "");

      let stream;

      function readBarcodeFromCanvas(canvas, format, mode) {
        var imgWidth = canvas.width;
        var imgHeight = canvas.height;
        var imageData = canvas.getContext('2d').getImageData(0, 0, imgWidth, imgHeight);
        var sourceBuffer = imageData.data;

        /*
        if (zxing != null) {
          var buffer = zxing._malloc(sourceBuffer.byteLength);
          zxing.HEAPU8.set(sourceBuffer, buffer);
          var result = zxing.readBarcodeFromPixmap(buffer, imgWidth, imgHeight, mode, format);
          zxing._free(buffer);
          return result;
        } else {
          return { error: "ZXing not yet initialized" };
        }
        */
        const sweep = document.getElementById('colorSweep')?.checked;
        return tryDecodeWithFilters(imageData, format, mode, !!sweep);
      }

      // Make a filtered copy of RGBA pixels into a fresh Uint8ClampedArray
      function makeFilteredBufferToLuminance(src, mode, w, h) {
        // writes into luminanceBuffer (1 byte per pixel)
        ensureLumBuffers(w, h);
        const L = luminanceBuffer;
        let j = 0;
        if (mode === 'red') {
          for (let i = 0; i < src.length; i += 4) L[j++] = src[i];
        } else if (mode === 'green') {
          for (let i = 0; i < src.length; i += 4) L[j++] = src[i+1];
        } else if (mode === 'blue') {
          for (let i = 0; i < src.length; i += 4) L[j++] = src[i+2];
        } else if (mode === 'invert') {
          for (let i = 0; i < src.length; i += 4) {
            // integer Rec.709: (54R + 183G + 19B)>>8
            L[j++] = 255 - ((54*src[i] + 183*src[i+1] + 19*src[i+2]) >> 8);
          }
        } else { // gray
          for (let i = 0; i < src.length; i += 4) {
            L[j++] = (54*src[i] + 183*src[i+1] + 19*src[i+2]) >> 8;
          }
        }
        return L;
      }

      // Try decoding the same frame with R-only, G-only, B-only, then Gray (first hit wins).
      function tryDecodeWithFilters(imageData, format, mode, sweepEnabled) {
        // If sweep is off: just try original (fast path)
        if (!sweepEnabled) {
          return readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, format, mode, /*isLuminance=*/false);
        }
        // Compute per-channel contrast to order passes
        const channels = ['red','green','blue'];
        const contrasts = channels.map(ch => {
          const buf = makeFilteredBufferToLuminance(imageData.data, ch, imageData.width, imageData.height);
          let min=255, max=0;
          for (let i=0;i<buf.length;i++){ const v=buf[i]; if (v<min) min=v; if (v>max) max=v; }
          return {ch, c:max-min};
        }).sort((a,b)=>b.c-a.c);
        const order = contrasts.map(o=>o.ch).concat(['gray','invert']);
        for (const pass of order) {
          const lum = makeFilteredBufferToLuminance(imageData.data, pass, imageData.width, imageData.height);
          if (!wasmLumPtr) ensureLumBuffers(imageData.width, imageData.height);
          zxing.HEAPU8.set(lum, wasmLumPtr);
          const res = zxing.readBarcodeFromPixmap(wasmLumPtr, imageData.width, imageData.height, 0, format);
          if (res && res.format && !res.error) return res;
        }
        // Fallback: original RGBA
        return readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, format, mode, /*isLuminance=*/false);
      }

      // Lower-level: copy a given RGBA buffer to ZXing heap and call into WASM once
      function readBarcodeFromCanvasInternal(rgbaBuffer, imgWidth, imgHeight, format, mode, isLuminance=false) {
        if (!zxing) return { error: "ZXing not yet initialized" };
        if (isLuminance) {
          ensureLumBuffers(imgWidth, imgHeight);
          zxing.HEAPU8.set(rgbaBuffer, wasmLumPtr);
          return zxing.readBarcodeFromPixmap(wasmLumPtr, imgWidth, imgHeight, 0, format);
        } else {
          const ptr = zxing._malloc(rgbaBuffer.byteLength);
          try {
            zxing.HEAPU8.set(rgbaBuffer, ptr);
            return zxing.readBarcodeFromPixmap(ptr, imgWidth, imgHeight, mode, format);
          } finally {
            zxing._free(ptr);
          }
        }
      }

      function drawResult(code) {
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "red";
        // ctx.textAlign = "center";
        // ctx.fillStyle = "#green"
        // ctx.font = "25px Arial";
        // ctx.fontWeight = "bold";
        with (code.position) {
          ctx.moveTo(topLeft.x, topLeft.y);
          ctx.lineTo(topRight.x, topRight.y);
          ctx.lineTo(bottomRight.x, bottomRight.y);
          ctx.lineTo(bottomLeft.x, bottomLeft.y);
          ctx.lineTo(topLeft.x, topLeft.y);
          ctx.stroke();
          // ctx.fillText(code.text, (topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);
        }
      }

      function escapeTags(htmlStr) {
        return htmlStr.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }

      let lastDecodeTime = 0;
      const DECODE_INTERVAL = 100; // ~10fps decode cadence

      const processFrame = function (now=performance.now()) {
        if (!scanning) return;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (now - lastDecodeTime >= DECODE_INTERVAL) {
          lastDecodeTime = now;
          const code = readBarcodeFromCanvas(canvas, format.value, mode.value === 'true');
          if (code && code.format) {
            resultElement.innerText = code.text;
            dScans[ code.text ] = '1';
            szCachedLastScan = code.text;
            scheduleProcessScanData();
            drawResult(code);
          }
        }
        if (video.requestVideoFrameCallback) { video.requestVideoFrameCallback(processFrame); } else { requestAnimationFrame(processFrame); }
      };

      const updateVideoStream = async function (deviceId) {
        // To ensure the camera switch, it is advisable to free up the media resources
        if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

        const constraints = {
          video: {
            facingMode: cameraSelector.value,
            focusMode: "manual"
          },
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        //check if focus control is supported
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        if (capabilities.focusDistance) {
          focusControl.disabled = false;
          focusControl.min = capabilities.focusDistance.min;
          focusControl.max = capabilities.focusDistance.max;
          focusControl.step = capabilities.focusDistance.step || 1;

          // Set initial focus
          updateFocus(focusControl.value);
        } else {
          focusControl.disabled = true;
          console.warn("Focus control is not supported on this device.");
        }
        //end focus
        video.setAttribute("playsinline", true); // iOS inline
        const startPlayback = async () => {
          try { await video.play(); } catch (e) { console.warn('video.play() was blocked or failed:', e); }
          processFrame();
        };
        if (video.readyState >= 1) { startPlayback(); }
        else { video.addEventListener('loadedmetadata', startPlayback, { once: true }); }

      };

      cameraSelector.addEventListener("change", function () { stopCamera(); startCamera(true); });

      // updateVideoStream(); (disabled; use Start/Stop flow)

      /*
        Update foucs, called when the focus slider moves.
      */
      function updateFocus(value) {
        const track = stream.getVideoTracks()[0];
        //console.log(track);
        track.applyConstraints({
          advanced: [{ focusDistance: value }],
        });
      }

      // Function to populate cameraSelector with available video devices
      async function populateCameraSelector() {
        const cameraSelector = document.getElementById("cameraSelector");
        
        // Clear any existing options
        cameraSelector.innerHTML = "";

        try {
          // Get the list of media devices
          const devices = await navigator.mediaDevices.enumerateDevices();

          let cameraCount = 0;

          // Loop through devices and add only video input devices
          devices.forEach(device => {
            if (device.kind === 'videoinput') {
              const option = document.createElement("option");
              option.value = device.deviceId;
              option.text = device.label || `Camera ${++cameraCount}`;
              cameraSelector.appendChild(option);
            }
          });

          if (cameraSelector.options.length === 0) {
            const noCameraOption = document.createElement("option");
            noCameraOption.value = "";
            noCameraOption.text = "No cameras found";
            cameraSelector.appendChild(noCameraOption);
          }
        } catch (error) {
          console.error("Error accessing media devices:", error);
          const errorOption = document.createElement("option");
          errorOption.value = "";
          errorOption.text = "Error accessing cameras";
          cameraSelector.appendChild(errorOption);
        }
      }
       
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      }

      // Helper: warn when not in a secure context (getUserMedia requires HTTPS or localhost)
      if (!window.isSecureContext) {
        console.warn('Not a secure context. Use https:// or http://localhost for camera access.');
      }

      // Attempt to auto-start camera when possible (works in production HTTPS and localhost).
      document.addEventListener('DOMContentLoaded', () => {
        if (window.isSecureContext || location.hostname === 'localhost') {
          startCamera(false).catch(() => {
            // ignore; user can click Start
          });
        }
      });
</script>
  </body>

</html>
