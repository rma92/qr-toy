<!DOCTYPE html>
<html>

  <head>
    <title>HotQR scanner</title>
    <link rel="shortcut icon" href="#" />
    <script src="zxing_reader.js"></script>
    <script src="lzma_worker-min.js"></script>
    <script src="hotqr_reader.js"></script>
    <!--<script src="zxing_reader.unmin.js"></script>-->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="HotQR Scanner">
    <link rel="apple-touch-icon" sizes="144x144" href="htqr_read.png">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
<style>
html, body{ margin:0;padding:0}
#canvas {
  width: 98vw; /* 100% of the viewport width */
  padding:0;
  margin:0;
  max-width: 800px;
  height: auto; /* maintain aspect ratio */
  display: block;
  border: 2px solid red;
}

</style>
  </head>

  <body style="text-align: center">
    <table><tr>
        <td>
          Camera:<br/>
          <select id="cameraSelector">
            <option value="user">Front Camera</option>
            <option value="environment">Back Camera</option>
          </select>
        </td>
        <td>
          Format:<br/>
          <select id="format">
            <option value="">Any</option>
            <option value="Aztec">Aztec</option>
            <option value="Code39">Codabar</option>
            <option value="CODE_39">Code39</option>
            <option value="Code93">Code93</option>
            <option value="Code128">Code128</option>
            <option value="DataMatrix">DataMatrix</option>
            <option value="DataBar">DataBar</option>
            <option value="DataBarExpanded">DataBarExpanded</option>
            <option value="DataBarLimited">DataBarLimited</option>
            <option value="DXFilmEdge">DXFilmEdge</option>
            <option value="EAN8">EAN-8</option>
            <option value="EAN13">EAN-13</option>
            <option value="ITF">ITF</option>
            <option value="PDF417">PDF417</option>
            <option value="QRCode" selected>QRCode</option>
            <option value="MicroQRCode">Micro QRCode</option>
            <option value="RMQRCode">rMQR Code</option>
            <option value="UPCA">UPC-A</option>
            <option value="UPCE">UPC-E</option>
            <option value="LinearCodes">Linear Codes</option>
            <option value="MatrixCodes">Matrix Codes</option>
          </select>
        </td>
        <td>
          <label><input id="colorSweep" type="checkbox" checked>R→G→B→Gray</label>
        </td>
        <td>
          Mode:<br/>
          <select id="mode">
            <option value="true" selected="">Normal</option>
            <option value="false">Fast</option>
          </select>
        </td>
        <td>
          Focus:<br />
          <input id="focusControl" type="range" min="0" max="100" value="50" />
        </td>
        <td>
          Info:<br/>
          <input id="inputTextOut" />
        </td>
      </tr>
    </table>
    <br /><br />

      <div style="margin: 8px 0; display:flex; gap:8px; align-items:center;">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
        <span id="cameraStatus" style="font-size:0.9em;opacity:0.75;"></span>
      </div>

    <canvas id="canvas" width="640" height="480"></canvas>
    <br /><br />
    <div id="scanview" style="width:420px"></div>

    <div id="result"></div>

    <div id="file-links"></div>
    <div id="qr-reader-results"></div>
    <script>
      function isPhone() {
        return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      //if iPhone:
      if (isPhone())
      {
        document.getElementById('cameraSelector').value = "environment";
      }
      else
      {
        document.getElementById('cameraSelector').value = "user"; // front camera
      }

    </script>
    <script>
      var zxing = ZXing().then(function (instance) {
        zxing = instance; // this line is supposedly not required but with current emsdk it is :-/
      });
      
      const cameraSelector = document.getElementById("cameraSelector");
      const focusControl = document.getElementById("focusControl");      
      const format = document.getElementById("format");
      const mode = document.getElementById("mode");
      const canvas = document.getElementById("canvas");
      const resultElement = document.getElementById("result");

      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      // Debounced processScanData
      let _psdTimer = 0;
      function scheduleProcessScanData() {
        if (typeof processScanData !== 'function') return;
        if (_psdTimer) cancelAnimationFrame(_psdTimer);
        _psdTimer = requestAnimationFrame(() => { try { scheduleProcessScanData(); } catch (e) { console.warn('processScanData failed:', e); } });
      }

      // --- Scanner control state ---
      let scanning = false;
      let stream = null;
      const startBtn = document.getElementById('startBtn');
      const stopBtn  = document.getElementById('stopBtn');
      const cameraStatus = document.getElementById('cameraStatus');
      function setStatus(msg) { if (cameraStatus) cameraStatus.textContent = msg || ''; }

      async function startCamera(manual=false) {
        // autoplay-friendly attributes
        try {
          video.setAttribute('playsinline','');
          video.setAttribute('autoplay','');
          video.setAttribute('muted','');
          video.playsInline = true;
          video.autoplay = true;
          video.muted = true;
        } catch {}
        if (scanning) return;
        try {
          const constraints = { video: { facingMode: cameraSelector.value || 'environment' } };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          try { await video.play(); } catch (e) {
            console.warn('video.play() blocked; tap Start.', e);
            if (!manual) setStatus('Tap anywhere or press "Start Camera"');
          }
          scanning = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          setStatus('Camera running');
          requestAnimationFrame(processFrame);
        } catch (err) {
          console.error('Camera start failed:', err);
          setStatus('Camera error: ' + (err && err.name ? err.name : err));
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      }

      function stopCamera() {
        if (!scanning) return;
        scanning = false;
        if (stream) { try { stream.getTracks().forEach(t=>t.stop()); } catch {} stream = null; }
        video.srcObject = null;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('Camera stopped');
      }

      startBtn.addEventListener('click', () => startCamera(true));
      stopBtn.addEventListener('click', stopCamera);

      const video = document.createElement("video");
      //var track;

      video.setAttribute("id", "video");
      video.setAttribute("width", canvas.width);
      video.setAttribute("height", canvas.height);
      video.setAttribute("autoplay", "");

      let stream;

      function readBarcodeFromCanvas(canvas, format, mode) {
        var imgWidth = canvas.width;
        var imgHeight = canvas.height;
        var imageData = canvas.getContext('2d').getImageData(0, 0, imgWidth, imgHeight);
        var sourceBuffer = imageData.data;

        /*
        if (zxing != null) {
          var buffer = zxing._malloc(sourceBuffer.byteLength);
          zxing.HEAPU8.set(sourceBuffer, buffer);
          var result = zxing.readBarcodeFromPixmap(buffer, imgWidth, imgHeight, mode, format);
          zxing._free(buffer);
          return result;
        } else {
          return { error: "ZXing not yet initialized" };
        }
        */
        const sweep = document.getElementById('colorSweep')?.checked;
        return tryDecodeWithFilters(imageData, format, mode, !!sweep);
      }

      // Make a filtered copy of RGBA pixels into a fresh Uint8ClampedArray
      function makeFilteredBuffer(src, mode) {
        const out = new Uint8ClampedArray(src.length);
        for (let i = 0; i < src.length; i += 4) {
          const r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];
          let R=r, G=g, B=b;
          if (mode === 'red')     { G = 0; B = 0; }
          else if (mode === 'green'){ R = 0; B = 0; }
          else if (mode === 'blue') { R = 0; G = 0; }
          else if (mode === 'gray') {
            // Rec. 709 luma
            const y = (0.2126*r + 0.7152*g + 0.0722*b) | 0;
            R = G = B = y;
          }
          out[i] = R; out[i+1] = G; out[i+2] = B; out[i+3] = a;
        }
        return out;
      }

      // Try decoding the same frame with R-only, G-only, B-only, then Gray (first hit wins).
      function tryDecodeWithFilters(imageData, format, mode, sweepEnabled) {
        // 1) If sweep is off: just try original (fast path)
        if (!sweepEnabled) {
          return readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, format, mode);
        }
        // 2) Sweep: red -> green -> blue -> gray
        const order = ['red','green','blue','gray'];
        for (const pass of order) {
          const buf = makeFilteredBuffer(imageData.data, pass);
          const res = readBarcodeFromCanvasInternal(buf, imageData.width, imageData.height, format, mode);
          if (res && res.format && !res.error) return res;
        }
        // 3) Fallback: original
        return readBarcodeFromCanvasInternal(imageData.data, imageData.width, imageData.height, format, mode);
      }

      // Lower-level: copy a given RGBA buffer to ZXing heap and call into WASM once
      function readBarcodeFromCanvasInternal(rgbaBuffer, imgWidth, imgHeight, format, mode) {
        if (!zxing) return { error: "ZXing not yet initialized" };
        const ptr = zxing._malloc(rgbaBuffer.byteLength);
        try {
          zxing.HEAPU8.set(rgbaBuffer, ptr);
          return zxing.readBarcodeFromPixmap(ptr, imgWidth, imgHeight, mode, format);
        } finally {
          zxing._free(ptr);
        }
      }

      function drawResult(code) {
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "red";
        // ctx.textAlign = "center";
        // ctx.fillStyle = "#green"
        // ctx.font = "25px Arial";
        // ctx.fontWeight = "bold";
        with (code.position) {
          ctx.moveTo(topLeft.x, topLeft.y);
          ctx.lineTo(topRight.x, topRight.y);
          ctx.lineTo(bottomRight.x, bottomRight.y);
          ctx.lineTo(bottomLeft.x, bottomLeft.y);
          ctx.lineTo(topLeft.x, topLeft.y);
          ctx.stroke();
          // ctx.fillText(code.text, (topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);
        }
      }

      function escapeTags(htmlStr) {
        return htmlStr.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }

      const processFrame = function () {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const code = readBarcodeFromCanvas(canvas, format.value, mode.value === 'true');
        if (code.format) {
          //resultElement.innerText = code.format + ": " + escapeTags(code.text);
          resultElement.innerText = code.text;

          //HotQr    
          //add the scan.
          dScans[ code.text ] = '1';
          szCachedLastScan = code.text;
          scheduleProcessScanData();
          //End HotQR.
          drawResult(code)
        } else {
          resultElement.innerText = "No barcode found";
        }
        requestAnimationFrame(processFrame);
      };


      const updateVideoStream = async function (deviceId) {
        // To ensure the camera switch, it is advisable to free up the media resources
        if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

        const constraints = {
          video: {
            facingMode: cameraSelector.value,
            focusMode: "manual"
          },
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        //check if focus control is supported
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        if (capabilities.focusDistance) {
          focusControl.disabled = false;
          focusControl.min = capabilities.focusDistance.min;
          focusControl.max = capabilities.focusDistance.max;
          focusControl.step = capabilities.focusDistance.step || 1;

          // Set initial focus
          updateFocus(focusControl.value);
        } else {
          focusControl.disabled = true;
          console.warn("Focus control is not supported on this device.");
        }
        //end focus
        video.setAttribute("playsinline", true); // required to tell iOS safari we don't want fullscreen
        video.play();
        processFrame();

      };

      cameraSelector.addEventListener("change", function () {
        updateVideoStream(this.value);
      });

      updateVideoStream();

      /*
        Update foucs, called when the focus slider moves.
      */
      function updateFocus(value) {
        const track = stream.getVideoTracks()[0];
        //console.log(track);
        track.applyConstraints({
          advanced: [{ focusDistance: value }],
        });
      }

      // Function to populate cameraSelector with available video devices
      async function populateCameraSelector() {
        const cameraSelector = document.getElementById("cameraSelector");
        
        // Clear any existing options
        cameraSelector.innerHTML = "";

        try {
          // Get the list of media devices
          const devices = await navigator.mediaDevices.enumerateDevices();

          let cameraCount = 0;

          // Loop through devices and add only video input devices
          devices.forEach(device => {
            if (device.kind === 'videoinput') {
              const option = document.createElement("option");
              option.value = device.deviceId;
              option.text = device.label || `Camera ${++cameraCount}`;
              cameraSelector.appendChild(option);
            }
          });

          if (cameraSelector.options.length === 0) {
            const noCameraOption = document.createElement("option");
            noCameraOption.value = "";
            noCameraOption.text = "No cameras found";
            cameraSelector.appendChild(noCameraOption);
          }
        } catch (error) {
          console.error("Error accessing media devices:", error);
          const errorOption = document.createElement("option");
          errorOption.value = "";
          errorOption.text = "Error accessing cameras";
          cameraSelector.appendChild(errorOption);
        }
      }
       
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      }
      
    
      document.addEventListener('DOMContentLoaded', () => {
        if (window.isSecureContext || location.hostname === 'localhost') {
          startCamera(false).catch(() => {});
        }
      });
</script>
  </body>

</html>
